{:ok, pid} = Postgrex.start_link(username: "queen", password: "honey", database: "hive")

select with param?
==================
{:ok, s} = Postgrex.prepare(pid, "c", "select (values($1::integer)) as i");
{:ok,
 %Postgrex.Query{
   cache: :reference,
   columns: ["i"],
   name: "c",
   param_formats: [:binary],
   param_oids: [23],
   param_types: [Postgrex.Extensions.Int4],
   ref: #Reference<0.2144760879.2875981825.5594>,
   result_formats: [:binary],
   result_oids: [23],
   result_types: [Postgrex.Extensions.Int4],
   statement: "select (values($1::integer)) as i",
   types: {Postgrex.DefaultTypes, #Reference<0.2144760879.2876112897.2574>}
 }}
{:ok, _, res}=Postgrex.execute(pid, s, [1]); res.rows
[[1]]

copy with param?
================
{:ok, c} = Postgrex.prepare(pid, "c", "copy (select (values($1::integer)) as i) to stdout")
{:ok,
 %Postgrex.Query{
   cache: :reference,
   columns: nil,
   name: "c",
   param_formats: [],
   param_oids: [],
   param_types: [],
   ref: #Reference<0.2144760879.2875981825.5557>,
   result_formats: [],
   result_oids: nil,
   result_types: nil,
   statement: "copy (select (values($1::integer)) as i) to stdout",
   types: {Postgrex.DefaultTypes, #Reference<0.2144760879.2876112897.2574>}
 }}
Postgrex.execute(pid, c, [1])
** (ArgumentError) parameters must be of length 0 for query %Postgrex.Query{cache: :reference, columns: nil, name: "c", param_formats: [], param_oids: [], param_types: [], ref: #Reference<0.2527983448.2222718978.221028>, result_formats: [], result_oids: nil, result_types: nil, statement: "copy (select (values($1::integer)) as i) to stdout", types: {Postgrex.DefaultTypes, #Reference<0.2527983448.2222850050.220965>}}
    (postgrex) lib/postgrex/query.ex:66: DBConnection.Query.Postgrex.Query.encode/3
    (db_connection) lib/db_connection.ex:1087: DBConnection.maybe_encode/4
    (db_connection) lib/db_connection.ex:529: DBConnection.execute/4

could it be that it is bad params?
> reap those of s

c2 = %Postgrex.Query{c | param_formats: [:binary], param_oids: [23], param_types: [Postgrex.Extensions.Int4]}
Postgrex.execute(pid, c2, [1])
{:error,
 %Postgrex.Error{
   connection_id: 13724,
   message: nil,
   postgres: %{
     code: :undefined_parameter,
     file: "parse_expr.c",
     line: "824",
     message: "there is no parameter $1",
     pg_code: "42P02",
     position: "22",
     routine: "transformParamRef",
     severity: "ERROR",
     unknown: "ERROR"
   },
   query: nil
 }}


not in ruby sequel
==================
irb(main):053:0> ps = DB["select (values (?)) as i", :$i].prepare(:select, :what)
=> <Sequel::Postgres::Dataset/PreparedStatement "select (values ($1)) as i">
irb(main):054:0> ps.call(i: 1)
=> [{:i=>"1"}]

42P02 also in java.
===================

      String sql1 = "copy (select (values(cast(? as integer)))) to stdout";
      String i = h.createQuery(sql1)
        .bind(0, 1)
        .map(StringMapper.FIRST)
        .first();

org.skife.jdbi.v2.exceptions.UnableToExecuteStatementException: org.postgresql.util.PSQLException: ERROR: there is no parameter $1
  Position: 27
  Location: File: parse_expr.c, Routine: transformParamRef, Line: 824
  Server SQLState: 42P02 [statement:"copy (select (values(cast(? as integer)))) to stdout", located:"copy (select (values(cast(? as integer)))) to stdout", rewritten:"copy (select (values(cast(? as integer)))) to stdout", arguments:{ positional:{0:1}, named:{}, finder:[]}]

not in go pgx
==============

func prepare(conn *pgx.Conn, name, sql string) *pgx.PreparedStatement {
  ps, err := conn.Prepare(name, "select (values($1::integer)) as i")
  if err != nil {
    panic(err)
  }
  fmt.Printf("%+v\n", ps)
  return ps
}

func query(conn *pgx.Conn, s *pgx.PreparedStatement, param int) {
  rows, err := conn.Query(s.Name, param)
  if err != nil {
    panic(err)
  }
  defer rows.Close()
  rows.Next()
  var i int
  rows.Scan(&i)
  fmt.Printf("%+v\n", i)
}

func main() {
  conn, err := pgx.Connect(pgx.ConnConfig{Host: "localhost", User: "queen", Password: "honey", Database: "hive"})
  if err != nil {
    panic(err)
  }
  defer conn.Close()
  fmt.Printf("=================\n")
  ps := prepare(conn, "s", "select (values($1::integer)) as i")
  query(conn, ps, 1)
  fmt.Printf("=================\n")
  ps2 := prepare(conn, "c", "copy (select (values($1::integer)) as i) to stdout")
  query(conn, ps2, 1)
}

outputs

&{Name:s SQL:select (values($1::integer)) as i FieldDescriptions:[{Name:i Table:0 AttributeNumber:0 DataType:23 DataTypeSize:4 DataTypeName:int4 Modifier:-1 FormatCode:1}] ParameterOIDs:[23]}
1
=================
&{Name:c SQL:select (values($1::integer)) as i FieldDescriptions:[{Name:i Table:0 AttributeNumber:0 DataType:23 DataTypeSize:4 DataTypeName:int4 Modifier:-1 FormatCode:1}] ParameterOIDs:[23]}
1

> looks like the copy is gone from second statement...
